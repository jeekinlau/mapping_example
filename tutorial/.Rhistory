genoprob  <- vector("list", 7)
for(i in 1:7){
genoprob[[i]] <- calc_genoprob_error(input.map = map[[i]], error = error, verbose = F)
}
print("calculating homologprob")
homoprobs = calc_homologprob(genoprob, verbose=F)
print("comparing to orginal")
P=unlist(lapply(map, function(x) x$maps[[1]]$seq.ph$P), recursive=F)
Q=unlist(lapply(map, function(x) x$maps[[1]]$seq.ph$Q), recursive=F)
P_matrix=matrix(0,nrow=length(P),ncol=ploidy)
Q_matrix=matrix(0,nrow=length(Q),ncol=ploidy)
#colnames(P_matrix)=c("a","b","c","d")
#colnames(Q_matrix)=c("e","f","g","h")
for(i in 1:nrow(P_matrix)){
P_matrix[i,unlist(P[i])]=1
}
for(i in 1:nrow(Q_matrix)){
Q_matrix[i,unlist(Q[i])]=1
}
mrks_mapped=unlist(lapply(map, function(x) x$info$mrk.names) )
PQ_matrix=cbind(P_matrix,Q_matrix)
rownames(PQ_matrix)=mrks_mapped
colnames(PQ_matrix)=c(letters[1:(ploidy*2)])
homoprob=homoprobs$homoprob
inds = unique(homoprob$individual)
mrks = unique(homoprob$marker)
temp = matrix(NA,length(mrks),length(inds))
rownames(temp)=mrks
colnames(temp)=inds
homoprob=as.matrix(homoprob)
homoprob_ind <- split.data.frame(homoprob, homoprob[,3])
test <- sapply(homoprob_ind, function(x) {
by_marker <- split.data.frame(x, x[,1])
final_matrix <- t(sapply(by_marker, function(y) y[order(y[,4], decreasing = T),][1:4,2]))
final_vector <- apply(final_matrix, 1, function(w) paste0(w, collapse = ""))
return(final_vector)
})
test=test[,order(colnames(test))]
test=test[match(mrks,rownames(test)),]
finished = test
for(a in 1:length(mrks)){
for(b in 1:length(inds)){
finished[a,b]=sum(PQ_matrix[a,substr(test[a,b], 1,1)],
PQ_matrix[a,substr(test[a,b], 2,2)],
PQ_matrix[a,substr(test[a,b], 3,3)],
PQ_matrix[a,substr(test[a,b], 4,4)])
}
#print(a)
}
original_geno=as.matrix(dat$geno.dose[which(rownames(dat$geno.dose)%in%mrks),])
original_geno=original_geno[,order(colnames(original_geno))]
identical(colnames(finished), colnames(original_geno))
identical(original_geno, finished)
which(!original_geno==finished)
original_geno[which(!original_geno==finished)]
percent_imputed=length(which(!original_geno==finished&original_geno==5))/length(original_geno)*100
percent_changed=length(which(!original_geno==finished&!original_geno==5))/length(original_geno)*100
colors = c("red","chartreuse","black")
empty_matrix=matrix(0,nrow(original_geno),ncol(original_geno))
empty_matrix[which(original_geno==finished)]="unchanged"
empty_matrix[which(!original_geno==finished&original_geno==5)]="imputed"
empty_matrix[which(!original_geno==finished&!original_geno==5)]="changed"
empty_matrix_melt=melt(empty_matrix)
plot1<-ggplot(empty_matrix_melt, aes(X1, X2, fill= factor(value))) +
geom_tile()+scale_fill_manual(values=colors)+
xlab("Markers")+
ylab("Individuals")+
ggtitle(paste0("changed = ",round(percent_changed, digits=3),"% ","imputed = ", round(percent_imputed, digits=3),"%"))
print("done")
return(plot1)
}
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset.csv", ploidy = 4)
setwd("~/GitHub/mapping_example/tutorial")
summary_maps(MAPs.err)
summary_maps(MAPs_nodup.err)
num_chr=length(unique(dat$chrom)))
num_chr=length(unique(dat$chrom))
dat <- get(map[[1]]$info$data.name)
ploidy <- map[[1]]$info$ploidy
num_chr=length(unique(dat$chrom))
print("calculating genoprob error")
genoprob  <- vector("list", num_chr)
for(i in 1:num_chr){
genoprob[[i]] <- calc_genoprob_error(input.map = map[[i]], error = error, verbose = F)
}
map_list=MAPs
dat <- get(map[[1]]$info$data.name)
ploidy <- map[[1]]$info$ploidy
num_chr=length(unique(dat$chrom))
print("calculating genoprob error")
genoprob  <- vector("list", num_chr)
for(i in 1:num_chr){
genoprob[[i]] <- calc_genoprob_error(input.map = map[[i]], error = error, verbose = F)
}
error=0.05
for(i in 1:num_chr){
genoprob[[i]] <- calc_genoprob_error(input.map = map[[i]], error = error, verbose = F)
}
print("calculating homologprob")
homoprobs = calc_homologprob(genoprob, verbose=T)
print("comparing to orginal")
P=unlist(lapply(map, function(x) x$maps[[1]]$seq.ph$P), recursive=F)
Q=unlist(lapply(map, function(x) x$maps[[1]]$seq.ph$Q), recursive=F)
P_matrix=matrix(0,nrow=length(P),ncol=ploidy)
Q_matrix=matrix(0,nrow=length(Q),ncol=ploidy)
View(P_matrix)
for(i in 1:nrow(P_matrix)){
P_matrix[i,unlist(P[i])]=1
}
View(P_matrix)
for(i in 1:nrow(Q_matrix)){
Q_matrix[i,unlist(Q[i])]=1
}
mrks_mapped=unlist(lapply(map, function(x) x$info$mrk.names) )
PQ_matrix=cbind(P_matrix,Q_matrix)
rownames(PQ_matrix)=mrks_mapped
colnames(PQ_matrix)=c(letters[1:(ploidy*2)])
homoprob=homoprobs$homoprob
inds = unique(homoprob$individual)
mrks = unique(homoprob$marker)
temp = matrix(NA,length(mrks),length(inds))
rownames(temp)=mrks
colnames(temp)=inds
homoprob=as.matrix(homoprob)
homoprob_ind <- split.data.frame(homoprob, homoprob[,3])
test <- sapply(homoprob_ind, function(x) {
by_marker <- split.data.frame(x, x[,1])
final_matrix <- t(sapply(by_marker, function(y) y[order(y[,4], decreasing = T),][1:4,2]))
final_vector <- apply(final_matrix, 1, function(w) paste0(w, collapse = ""))
return(final_vector)
})
test=test[,order(colnames(test))]
test=test[match(mrks,rownames(test)),]
finished = test
for(a in 1:length(mrks)){
for(b in 1:length(inds)){
finished[a,b]=sum(PQ_matrix[a,substr(test[a,b], 1,1)],
PQ_matrix[a,substr(test[a,b], 2,2)],
PQ_matrix[a,substr(test[a,b], 3,3)],
PQ_matrix[a,substr(test[a,b], 4,4)])
}
#print(a)
}
original_geno=as.matrix(dat$geno.dose[which(rownames(dat$geno.dose)%in%mrks),])
original_geno=original_geno[,order(colnames(original_geno))]
identical(colnames(finished), colnames(original_geno))
identical(original_geno, finished)
which(!original_geno==finished)
original_geno[which(!original_geno==finished)]
identical(original_geno, finished)
which(!original_geno==finished)
options(width = 100)
options(width = 100)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset.csv", ploidy = 4)
plot(dat)
## Filtering dataset by marker
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = F)
## Filtering dataset by individual
dat = filter_missing(input.data = dat, type = "individual",
filter.thres = 0.10, inter = F)
dat
dat_vcf = read_vcf("../data/sweetpotato_chr1.vcf.gz", parent.1 = "P1", parent.2 = "P2",ploidy = 6)
library(vcfR)
read.vcfR("../data/sweetpotato_chr1.vcf.gz")
vcf=read.vcfR("../data/sweetpotato_chr1.vcf.gz")
View(vcf)
colnam(vcf@gt)
colnames(vcf@gt)
dat_vcf = read_vcf("../data/sweetpotato_chr1.vcf.gz", parent.1 = "PARENT1", parent.2 = "PARENT2",ploidy = 6)
## Filtering dataset by marker
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = F)
## Filtering dataset by individual
dat = filter_missing(input.data = dat, type = "individual",
filter.thres = 0.10, inter = F)
dat
## Filtering dataset by marker
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = T)
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = T)
dat = filter_missing(input.data = dat, type = "individual",
filter.thres = 0.10, inter = T)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants.csv", ploidy = 4)
## Filtering dataset by marker
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = F)
## Filtering dataset by individual
dat = filter_missing(input.data = dat, type = "individual",
filter.thres = 0.10, inter = F)
dat
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = F)
seq.init = make_seq_mappoly(mrks.chi.filt)
seq.init
plot(seq.init)
## Accounting for recombination fractions
all.rf.pairwise = est_pairwise_rf(input.seq = seq.init, ncpus = 6)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_3113mrks.csv", ploidy = 4)
## Filtering dataset by marker
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = F)
## Filtering dataset by individual
dat = filter_missing(input.data = dat, type = "individual",
filter.thres = 0.10, inter = F)
dat
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = F)
seq.init = make_seq_mappoly(mrks.chi.filt)
seq.init
plot(seq.init)
## Accounting for recombination fractions
all.rf.pairwise = est_pairwise_rf(input.seq = seq.init, ncpus = 6)
mat = rf_list_to_matrix(all.rf.pairwise)
plot(mat)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4)
dat_vcf = read_vcf("../data/sweetpotato_chr1.vcf.gz", parent.1 = "PARENT1", parent.2 = "PARENT2",ploidy = 6)
## Filtering dataset by marker
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = F)
## Filtering dataset by individual
dat = filter_missing(input.data = dat, type = "individual",
filter.thres = 0.10, inter = F)
dat
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = F)
seq.init = make_seq_mappoly(mrks.chi.filt)
seq.init
plot(seq.init)
## Accounting for recombination fractions
all.rf.pairwise = est_pairwise_rf(input.seq = seq.init, ncpus = 6)
## Getting group information (UPGMA)
grs = group_mappoly(input.mat = mat,
expected.groups = 7,
comp.mat = TRUE,
inter = F)
View(dat)
## Getting group information (UPGMA)
grs = group_mappoly(input.mat = mat,
expected.groups = 7,
comp.mat = TRUE,
inter = F)
mat = rf_list_to_matrix(all.rf.pairwise)
plot(mat)
## Getting group information (UPGMA)
grs = group_mappoly(input.mat = mat,
expected.groups = 7,
comp.mat = TRUE,
inter = F)
grs
plot(grs)
## Making groups with intersection between UPGMA (rf) + genomic information (discards scaffolds)
LGS.inter=vector("list", 7)
for(j in 1:7){
temp1 = make_seq_mappoly(grs, j, genomic.info=1)
tpt = make_pairs_mappoly(all.rf.pairwise, input.seq = temp1)
temp2 = rf_snp_filter(input.twopt = tpt, diagnostic.plot = FALSE)
tpt2 = make_pairs_mappoly(tpt, input.seq = temp2)
LGS.inter[[as.numeric(names(table(temp2$chrom))[which.max(table(temp2$chrom))])]] = list(seq = temp2, tpt = tpt2)
}
## Making groups only with genomic information (tends to bring more markers, but also discards scaffolds)
LGS.genomic = vector("list", 7)
for (i in 1:7){
tempseq1 = make_seq_mappoly(dat, arg = paste0("seq",i), genomic.info = 1)
mrks = intersect(tempseq1$seq.mrk.names, seq.init$seq.mrk.names)
tempseq = make_seq_mappoly(dat, arg = mrks)
temptpt = make_pairs_mappoly(all.rf.pairwise, input.seq = tempseq)
rffilt = rf_snp_filter(input.twopt = temptpt, diagnostic.plot = FALSE)
temptpt2 = make_pairs_mappoly(temptpt, input.seq = rffilt)
LGS.genomic[[as.numeric(unique(rffilt$chrom))]] = list(seq = rffilt, tpt = temptpt2)
}
## Making groups with UPGMA (rf) information (includes scaffolds)
LGS.upgma=vector("list", 7)
for(j in 1:7){
temp1 = make_seq_mappoly(grs, j)
tpt = make_pairs_mappoly(all.rf.pairwise, input.seq = temp1)
temp2 = rf_snp_filter(input.twopt = tpt, diagnostic.plot = FALSE)
tpt2 = make_pairs_mappoly(tpt, input.seq = temp2)
LGS.upgma[[as.numeric(names(table(temp2$chrom))[which.max(table(temp2$chrom))])]] = list(seq = temp2, tpt = tpt2)
}
## Comparing number of markers in each group
comp = data.frame(UPGMA_Genomic = unlist(lapply(LGS.inter, function(x) length(x$seq$seq.num))),
Genomic = unlist(lapply(LGS.genomic, function(x) length(x$seq$seq.num))),
UPGMA = unlist(lapply(LGS.upgma, function(x) length(x$seq$seq.num))))
comp
LGS<-LGS.inter
single_chrom <- est_rf_hmm_sequential(input.seq = LGS[[1]]$seq,
start.set = 3,
thres.twopt = 10,
thres.hmm = 50,
extend.tail = 30,
twopt = LGS[[1]]$tpt,
verbose = TRUE,
phase.number.limit = 20,
sub.map.size.diff.limit = 5)
plot(single_chrom)
## Performing parallel computation of hidden markov
phasing_and_hmm_rf <- function(X){
fl <- paste0("output_map_ch_", unique(X$seq$chrom), ".txt")
sink(fl)
map <- est_rf_hmm_sequential(input.seq = X$seq,
start.set = 3,
thres.twopt = 10,
thres.hmm = 50,
extend.tail = 30,
twopt = X$tpt,
verbose = TRUE,
phase.number.limit = 20,
sub.map.size.diff.limit = 5)
sink()
return(map)
}
# 5% genotyping error
my.error.func<-function(X){
x<-est_full_hmm_with_global_error(input.map = X,
error = 0.05,
tol = 10e-4,
verbose = FALSE)
return(x)
}
#upgma
#hidden markov based off physical location
ptm <- proc.time()
cl <- parallel::makeCluster(7)
parallel::clusterEvalQ(cl, require(mappoly))
parallel::clusterExport(cl, "dat")
MAPs <- parallel::parLapply(cl,LGS, phasing_and_hmm_rf)
parallel::stopCluster(cl)
# account for error
cl <- parallel::makeCluster(7)
parallel::clusterEvalQ(cl, require(mappoly))
parallel::clusterExport(cl, "dat")
MAPs.err <- parallel::parLapply(cl,MAPs,my.error.func)
parallel::stopCluster(cl)
par(mfrow=c(2,1))
plot_map_list(MAPs, col = "ggstyle")
plot_map_list(MAPs.err, col = "ggstyle")
proc.time() - ptm
plot_genome_vs_map(MAPs.err, same.ch.lg = T)
summary_maps(MAPs.err)
library(polymapR)
ALL_dosages =  export_data_to_polymapR(dat)
screened_data <- screen_for_duplicate_individuals(dosage_matrix = ALL_dosages,
cutoff = 0.95,
plot_cor = T)
PCA_progeny(screened_data)
View(dat)
dat$ind.names
View(ALL_dosages)
PCA_progeny(ALL_dosages)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4)
ALL_dosages =  export_data_to_polymapR(dat)
PCA_progeny(ALL_dosages)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4, filter.non.conforming = F)
polymapR_dosage_matrix=export_data_to_polymapR(dat)
PCA_progeny(polymapR_dosage_matrix)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4, filter.non.conforming = F)
library(polymapR)
polymapR_dosage_matrix=export_data_to_polymapR(dat)
PCA_progeny(polymapR_dosage_matrix)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4, filter.non.conforming = F)
library(polymapR)
polymapR_dosage_matrix=export_data_to_polymapR(dat)
PCA_progeny(polymapR_dosage_matrix)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4, filter.non.conforming = F)
library(polymapR)
polymapR_dosage_matrix=export_data_to_polymapR(dat)
PCA_progeny(polymapR_dosage_matrix)
PCA_progeny(polymapR_dosage_matrix)
contaminants = c("X16009_N001", "X16009_N010","SW","X16009_N005","X16009_N006","X16009_N009")
screened_data <- screen_for_duplicate_individuals(dosage_matrix = ALL_dosages,
cutoff = 0.95,
plot_cor = T)
View(screened_data)
duplicates =  c("X16035_N028.1", "X16035_N029.1","X16400_N023","X16400_N038","X16405_N113","X16400_N006")
genotype_data = read.csv("../data/BExMG_subset_with_contaminants_2075mrks.csv")
remove = c(contaminants,duplicates)
genotype_data[,which(!genotype_data%in%remove)]
genotype_data_after_QC=genotype_data[,which(!genotype_data%in%remove)]
genotype_data_after_QC=genotype_data[,which(!colnames(genotype_data)%in%remove)]
View(genotype_data_after_QC)
colnames(genotype_data_after_QC)
genotype_data = read.csv("../data/BExMG_subset_with_contaminants_2075mrks.csv")
write.csv(genotype_data_after_QC,"BExMG_subset_with_contaminants_2075mrks_afterQC.csv")
write.csv(genotype_data_after_QC,"BExMG_subset_with_contaminants_2075mrks_afterQC.csv", row.names = F)
write.csv(genotype_data_after_QC,"../data/BExMG_subset_with_contaminants_2075mrks_afterQC.csv", row.names = F)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks_afterQC.csv", ploidy = 4, filter.non.conforming = F)
## Filtering dataset by marker
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = F)
## Filtering dataset by individual
dat = filter_missing(input.data = dat, type = "individual",
filter.thres = 0.10, inter = F)
dat
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = F)
seq.init = make_seq_mappoly(mrks.chi.filt)
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = F)
seq.init = make_seq_mappoly(mrks.chi.filt)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks_afterQC.csv", ploidy = 4, filter.non.conforming = F)
## Filtering dataset by marker
dat = filter_missing(input.data = dat, type = "marker",
filter.thres = 0.10, inter = F)
## Filtering dataset by individual
dat = filter_missing(input.data = dat, type = "individual",
filter.thres = 0.10, inter = F)
dat
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = F)
seq.init = make_seq_mappoly(mrks.chi.filt)
View(mrks.chi.filt)
seq.init
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = t)
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = T)
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = T)
library(mappoly)
## Filter according to segregation test
pval.bonf = 0.05/dat$n.mrk
mrks.chi.filt = filter_segregation(dat, chisq.pval.thres =  pval.bonf, inter = F)
seq.init = make_seq_mappoly(mrks.chi.filt)
genoprob.err <- readRDS("~/GitHub/mapping_example/tutorial/genoprob.err.RDS")
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4, filter.non.conforming = F)
filter_individuals(dat)
setwd("~/GitHub/mapping_example/tutorial")
library(mappoly)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4, filter.non.conforming = F)
View(dat)
filter_dat=filter_individuals(dat)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4, filter.non.conforming = F)
filter_dat(dat)
filter_individuals(dat)
filter_individuals(dat)
dat = read_geno_csv(file="../data/BExMG_subset_with_contaminants_2075mrks.csv", ploidy = 4, filter.non.conforming = F)
filter_individuals(dat)
score.null <- readRDS("~/GitHub/mapping_example/tutorial/score.null.RDS")
genoprob.err <- readRDS("~/GitHub/mapping_example/tutorial/genoprob.err.RDS")
library(qtlpoly)
genoprob.err = readRDS(file="genoprob.err.RDS")
pheno = read.csv("../data/blackspot_cercospora_defoliation_RRD.csv", row.names = 1)
data = read_data(ploidy = 4, geno.prob = genoprob.err, pheno = pheno, step = 1)
# this step takes a long time so do not run import it
#data.sim = simulate_qtl(data = data, mu = 0, h2.qtl = NULL, var.error = 1, n.sim = 1000, missing = TRUE, seed = 123)
#score.null = null_model(data = data.sim$results, n.clusters = 7, plot = NULL)
score.null = readRDS("../data/score.null.RDS")
remim.mod = remim(data, score.null = score.null, w.size = 15, sig.fwd = 0.2, sig.bwd = 0.05, n.clusters = 7)
plot_profile(data, remim.mod, sup.int = T)
plot_profile(data, remim.mod, sup.int = T, grid=T)
plot_sint(data,remim.mod)
fitted.mod <- fit_model(data = data, model = remim.mod, probs = "joint", polygenes = "none")
summary(fitted.mod) #some reason this does not display right please run in the console to see results
knitr::kable(summary(fitted.mod)) #some reason this does not display right please run in the console to see results
summary(fitted.mod) #some reason this does not display right please run in the console to see results
fitted.mod <- fit_model(data = data, model = remim.mod, probs = "joint", polygenes = "none")
summary(fitted.mod) #some reason this does not display right please run in the console to see results
fitted.mod <- fit_model(data = data, model = remim.mod, probs = "joint", polygenes = "none")
summary(fitted.mod) #some reason this does not display right please run in the console to see results
{summary(fitted.mod)} #some reason this does not display right please run in the console to see results
summary(fitted.mod) #some reason this does not display right please run in the console to see results
fitted.mod
summary(fitted.mod) #some reason this does not display right please run in the console to see results
summary(fitted.mod)
```{r}
test=summary(fitted.mod)
knittr::kable(summary(fitted.mod))
knitr::kable(summary(fitted.mod))
fitted.mod <- fit_model(data = data, model = remim.mod, probs = "joint", polygenes = "none")
summary(fitted.mod) #some reason this does not display right please run in the console to see results
est.effects <- qtl_effects(ploidy = 4, fitted = fitted.mod)
plot(est.effects)
fitted.mod <- fit_model(data = data, model = remim.mod, probs = "joint", polygenes = "none")
summary(fitted.mod) #some reason this does not display right please run in the console to see results
summary(fitted.mod)
fitted.mod <- fit_model(data = data, model = remim.mod, probs = "joint", polygenes = "none")
summary(fitted.mod) #some reason this does not display right please run in the console to see results
fitted.mod <- fit_model(data = data, model = remim.mod, probs = "joint", polygenes = "none")
summary(fitted.mod) #some reason this does not display right please run in the console to see results
